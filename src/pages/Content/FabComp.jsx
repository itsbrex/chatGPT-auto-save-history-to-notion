import React from 'react';
import Fab from '@mui/material/Fab';
import SmartToySharpIcon from "@mui/icons-material/SmartToySharp";
import Turndown from "turndown";

const fabStyle = {
    margin: 0,
    top: 'auto',
    right: 20,
    bottom: 20,
    left: 'auto',
    position: 'fixed'
}

// const callBackground = async () => {
//     console.log("sending message to background");
//
//     console.log('what is this ' + chrome.runtime.id)
//
//     console.log("chrome runtime " + chrome.runtime.getBackgroundPage)
//     // In the content script:
//     if (chrome.runtime.getBackgroundPage) {
//         chrome.runtime.getBackgroundPage((backgroundPage) => {
//             backgroundPage.runMyScript();
//             console.log("here after calling bp");
//         })
//     }
//     const response = await chrome.runtime.sendMessage({ type: "runMyScript" });
//     if (response) {
//         console.log("here in content script" + response.resMessage);
//     }
//
// }

const turnToMarkdown = () => {


    const turndown = new Turndown({
        headingStyle: 'atx' // headings will be converted to "## Heading"
    });

    // const domNode = document.querySelector('main');
    // const markdown = turndown.turndown(domNode);

    // console.log(markdown)

    const chatData = get_current_chat_text()

    console.log(document.title)

    console.log(chatData[0])


  let string = "";
  if(document.title) {
    string += "# " + document.title + "<br>";
  } else {
    string += "# " + "ChatGPT Conversation" + "<br>";
  }
  string += "<br>";

    string+=chatData.toString()

    console.log(turndown.turndown(string));

}

function get_current_chat_text() {
    let mainElement = document.querySelector("main");
    // should be more robust, can't see how they would change the flex col anytime soon
    let chatContainer = mainElement.querySelector(".flex-col");
    // what is one part of a conversation called again? let's just call it a chat bubble
    let chatBubbleElements = chatContainer.children;
    let chat = [];

    // remember to disregard the last element, which is always a filler element
    for(let i = 0; i < chatBubbleElements.length-1; i++)
    {
        let isHuman = (i % 2) === 0;
        let chatBubble = chatBubbleElements[i];
        let text = get_chat_bubble_text(chatBubble, isHuman);
        chat.push(text);
    }

    return chat;
}

// gets chat with errors, for current export.
function get_chat_bubble_text(chatBubble, isHuman)
{
    let text;
    if(isHuman) {
        text = chatBubble.innerText;
        if(text.includes("Save & Submit\nCancel"))
        {
            // query the textarea instead
            text = chatBubble.querySelector("textarea")?.value;
        }
        // for code
        text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    } else {
        text = saveChildInnerHTML(chatBubble.firstChild.children[1].firstChild.firstChild.firstChild) // saves as html
    }
    return text;
}

function saveChildInnerHTML(parent, clone = true) { // generated by ChatGPT
    // Get the child elements of the parent
    let p1;
    document.body.appendChild(document.createElement(`div`)).setAttribute("id", "chat_history");
    let history_box = document.querySelector("#chat_history");
    if (clone) {
        p1 = parent.cloneNode(true)
        p1.setAttribute("style", "display: none;");
        history_box.innerHTML = "";
        history_box.appendChild(p1);
    } else {
        p1 = parent
    }
    var children = p1.children;

    // Create a string to store the innerHTML of each child
    var childInnerHTML = '';

    // Loop through each child element
    for (var i = 0; i < children.length; i++) {
        // Clone the child element
        var child = children[i];
        if (child.tagName === "PRE") {
            let div = child.firstChild.children[1]
            div.firstChild.classList.add('p-4')
            let text = div.innerHTML
            let clipboard = `<i class="fa-regular clipboard fa-clipboard"></i>`
            let copy_bar = `<div class="p-2 copy float-right">${clipboard} &nbsp; Copy code</div>`
            let template = `<pre>${copy_bar}<div>${text}</div></pre><br>`
            childInnerHTML += template;
        } else {
            // Remove the child's class attribute
            child.removeAttribute("class");

            // Recursively call the function on the child's children
            saveChildInnerHTML(child, false);

            // Add the child's innerHTML to the string
            childInnerHTML += child.outerHTML;
        }
    }

    return childInnerHTML;
}

const FabComp = () => {
    return(
        <Fab style={fabStyle} aria-label="chatGPT" onClick={() => console.log('fab clicked')}>
            <SmartToySharpIcon />
        </Fab>
    )
}

export default FabComp;